{"version":3,"sources":["/mnt/d/Work/Angular/New folder (2)/DolceGrocery/node_modules/graphql-tag/src/index.js","./src/app/services/geo-location.ts"],"names":[],"mappings":"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","file":"default~by-code-by-code-module~merchants-merchants-module~products-products-module.js","sourcesContent":["var parser = require('graphql/language/parser');\n\nvar parse = parser.parse;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\n// A map docString -> graphql document\nvar docCache = {};\n\n// A map fragmentName -> [normalized source]\nvar fragmentSourceMap = {};\n\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// For testing.\nfunction resetCaches() {\n  docCache = {};\n  fragmentSourceMap = {};\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nvar printFragmentWarnings = true;\nfunction processFragments(ast) {\n  var astFragmentMap = {};\n  var definitions = [];\n\n  for (var i = 0; i < ast.definitions.length; i++) {\n    var fragmentDefinition = ast.definitions[i];\n\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n\n      // We know something about this fragment\n      if (fragmentSourceMap.hasOwnProperty(fragmentName) && !fragmentSourceMap[fragmentName][sourceKey]) {\n\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n\n      } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {\n        fragmentSourceMap[fragmentName] = {};\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n      }\n\n      if (!astFragmentMap[sourceKey]) {\n        astFragmentMap[sourceKey] = true;\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  }\n\n  ast.definitions = definitions;\n  return ast;\n}\n\nfunction disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nfunction stripLoc(doc, removeLocAtThisLevel) {\n  var docType = Object.prototype.toString.call(doc);\n\n  if (docType === '[object Array]') {\n    return doc.map(function (d) {\n      return stripLoc(d, removeLocAtThisLevel);\n    });\n  }\n\n  if (docType !== '[object Object]') {\n    throw new Error('Unexpected input.');\n  }\n\n  // We don't want to remove the root loc field so we can use it\n  // for fragment substitution (see below)\n  if (removeLocAtThisLevel && doc.loc) {\n    delete doc.loc;\n  }\n\n  // https://github.com/apollographql/graphql-tag/issues/40\n  if (doc.loc) {\n    delete doc.loc.startToken;\n    delete doc.loc.endToken;\n  }\n\n  var keys = Object.keys(doc);\n  var key;\n  var value;\n  var valueType;\n\n  for (key in keys) {\n    if (keys.hasOwnProperty(key)) {\n      value = doc[keys[key]];\n      valueType = Object.prototype.toString.call(value);\n\n      if (valueType === '[object Object]' || valueType === '[object Array]') {\n        doc[keys[key]] = stripLoc(value, true);\n      }\n    }\n  }\n\n  return doc;\n}\n\nvar experimentalFragmentVariables = false;\nfunction parseDocument(doc) {\n  var cacheKey = normalize(doc);\n\n  if (docCache[cacheKey]) {\n    return docCache[cacheKey];\n  }\n\n  var parsed = parse(doc, { experimentalFragmentVariables: experimentalFragmentVariables });\n  if (!parsed || parsed.kind !== 'Document') {\n    throw new Error('Not a valid GraphQL document.');\n  }\n\n  // check that all \"new\" fragments inside the documents are consistent with\n  // existing fragments of the same name\n  parsed = processFragments(parsed);\n  parsed = stripLoc(parsed, false);\n  docCache[cacheKey] = parsed;\n\n  return parsed;\n}\n\nfunction enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nfunction disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nfunction gql(/* arguments */) {\n  var args = Array.prototype.slice.call(arguments);\n\n  var literals = args[0];\n\n  // We always get literals[0] and then matching post literals for each arg given\n  var result = (typeof(literals) === \"string\") ? literals : literals[0];\n\n  for (var i = 1; i < args.length; i++) {\n    if (args[i] && args[i].kind && args[i].kind === 'Document') {\n      result += args[i].loc.source.body;\n    } else {\n      result += args[i];\n    }\n\n    result += literals[i];\n  }\n\n  return parseDocument(result);\n}\n\n// Support typescript, which isn't as nice as Babel about default exports\ngql.default = gql;\ngql.resetCaches = resetCaches;\ngql.disableFragmentWarnings = disableFragmentWarnings;\ngql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;\ngql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;\n\nmodule.exports = gql;\n","import { Injectable } from '@angular/core';\nimport { ILocation } from '@modules/server.common/interfaces/IGeoLocation';\nimport { Geolocation } from '@ionic-native/geolocation';\nimport GeoLocation from '@modules/server.common/entities/GeoLocation';\nimport { environment } from 'environments/environment';\nimport { Subscribable } from 'rxjs';\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\n\ninterface Coords {\n\tlongitude?: number;\n\tlatitude?: number;\n}\n\n@Injectable()\nexport class GeoLocationService {\n\tprivate headers: HttpHeaders = new HttpHeaders({\n\t\t'Content-Type': 'application/json',\n\t});\n\n\tconstructor(private http: HttpClient) {}\n\n\tgetCurrentGeoLocation(): Promise<GeoLocation> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst coords = await this.getCurrentCoords();\n\n\t\t\t\tconst location: ILocation = {\n\t\t\t\t\ttype: 'Point',\n\t\t\t\t\tcoordinates: [coords.longitude, coords.latitude],\n\t\t\t\t};\n\t\t\t\tif (!location) {\n\t\t\t\t\tthrow new Error(`Can't detect location`);\n\t\t\t\t}\n\n\t\t\t\tconst currentGeolocation = new GeoLocation({\n\t\t\t\t\t_id: '',\n\t\t\t\t\tloc: location,\n\t\t\t\t\tcountryId: null,\n\t\t\t\t\tcity: null,\n\t\t\t\t\tstreetAddress: null,\n\t\t\t\t\thouse: null,\n\t\t\t\t\t_createdAt: '',\n\t\t\t\t\t_updatedAt: '',\n\t\t\t\t});\n\n\t\t\t\tresolve(currentGeolocation);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n\n\tgetCurrentCoords(): Promise<Coords> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\tconst defaultLat = environment.DEFAULT_LATITUDE;\n\t\t\tconst defaultLng = environment.DEFAULT_LONGITUDE;\n\n\t\t\tif (defaultLat && defaultLng) {\n\t\t\t\tresolve(\n\t\t\t\t\tthis.getCoordsObj({\n\t\t\t\t\t\tlatitude: defaultLat,\n\t\t\t\t\t\tlongitude: defaultLng,\n\t\t\t\t\t})\n\t\t\t\t);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst { coords } = await Geolocation.getCurrentPosition();\n\n\t\t\t\tresolve(this.getCoordsObj(coords));\n\t\t\t} catch (error) {\n\t\t\t\tnavigator.geolocation.getCurrentPosition(\n\t\t\t\t\t(res) => {\n\t\t\t\t\t\t// If user is enable GPS on browser\n\t\t\t\t\t\tresolve(this.getCoordsObj(res.coords));\n\t\t\t\t\t},\n\t\t\t\t\t(err) => {\n\t\t\t\t\t\t// If user is denied GPS on browser\n\t\t\t\t\t\tthis.getLocationByIP().subscribe((res) => {\n\t\t\t\t\t\t\tif (res) {\n\t\t\t\t\t\t\t\tresolve(this.getCoordsObj(res));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treject(err.message);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate getLocationByIP(): Subscribable<Coords | null> {\n\t\treturn this.http.get(\n\t\t\tenvironment.SERVICES_ENDPOINT + '/getLocationByIP',\n\t\t\t{ headers: this.headers }\n\t\t);\n\t}\n\n\tprivate getCoordsObj(coords: Coords) {\n\t\treturn {\n\t\t\tlongitude: coords.longitude,\n\t\t\tlatitude: coords.latitude,\n\t\t};\n\t}\n}\n"],"sourceRoot":"webpack:///"}